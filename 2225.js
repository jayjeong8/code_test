//0부터 N까지의 수 중 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하기
//덧셈의 순서가 바뀌면 다른 경우로 센다(1+2, 2+1)
//하나의 수를 여러번 쓸 수 있다.
//첫째줄에 'N K'가 주어진다. "입력변수가 2개일 때는 2차원 배열로 고려해보자"
//답을 1,000,000,000 으로 나눈 나머지를 출력한다.

const input = require('fs').readFileSync('/dev/stdin', 'utf8').split(' ');
const N = +input[0];
const K = +input[1];

const mod = 1000000000;

const memo = new Array(K).fill(new Array(N + 1).fill(1));

//맨 뒷자리의 숫자를 고정시키고(2*n 타일링 문제처럼)들어올 수 있는 경우의 수 합을 구한다.
//[K][N]의 2차원 배열로 구한다. (2차원 배열을 그려보면 쉽게 이해할 수 있다.)
//K첫번째줄(0)과 N첫번째줄은 결과가 1이기 때문에 건너뛰고 1부터 시작한다.
for (let k = 1; k < K; k++) {
    for (let n = 1; n <= N; n++) {
        memo[k][n] = (memo[k][n - 1] + memo[k - 1][n]) % mod;
    }
}
//memo에서 K보다 작은 값들의 배열이 최종값으로 덮어씌워져있다.
//답에는 문제 없으나 배열을 제대로 만들고 싶다면 10884처럼 따로 임시 어레이로 값을 구하고 memo[k]에 넣어주는 방법이 있다.
console.log(memo[K-1][N]);